// Core server logic for Theminds. She takes a QuirkStart for input
// and outputs via the Line event. Very self-contained.

using System;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Threading;
using System.Diagnostics;

namespace Theminds {
	public struct QuirkStart {
		public string serv;
		public string nick;
		public string user;
		public int port;

		public string hostName;
	}
	
	// An IRC client class
	public sealed partial class Quirk : IDisposable {
		public QuirkStart Info;

		// Everytime Connection has a new line, we send it to this event.
		// NOT LogBox's NewLine. This merely glues Connection and LogBox.
		public delegate void LineDel(Quirk sender, string line);
		public event LineDel Line;

		static Random randomAddressIndex = new Random();
		static int nextId = 0;
		
		bool dnsResolved;
		public int Id;
		public Quirk(QuirkStart connectionInfo) {
			this.Info = connectionInfo;

			// Identifies different server instances even if they
			// both connect to the same server, possibly the only way
			// I can think of to do so. ID is generated by a static
			// counter (nextId).
			// Doing it by QuirkStart.nick might also be possible.
			this.Id = Quirk.nextId++;

			try {
				IPAddress[] x = Dns.GetHostEntry(connectionInfo.serv).AddressList;				
				this.Info.serv = x[randomAddressIndex.Next(x.Length)].ToString();
				dnsResolved = true;
			}
			catch (SocketException) {
				Line(this, String.Format(
					"Could not resolve {0} ({1}).", connectionInfo.serv, connectionInfo.hostName));
				dnsResolved = false;
				// TODO: throw exception for caller to catch.
			}
		}

		Thread connectThread;
		bool started;
		[Conditional("ENABLE_CONNECT")]
		public void Start() {
			if (false == dnsResolved) return;
			started = true;
			connectThread = new Thread(new ThreadStart(connect));
			connectThread.IsBackground = true;
			connectThread.Start();
		}

		public void Message(string line) {
			string unlined = line;
			Line(this, line);
			writer.WriteLine(unlined);
		}

		// IDisposable
		bool disposed;
		public void Dispose() { Dispose(null); }
		public void Dispose(string quitMsg) {
			if (disposed || false == dnsResolved || false == started) return;

			if (null == quitMsg) Message("QUIT");
			else Message("QUIT " + quitMsg);

			abortConnect = true;
			connectThread.Join(1000);

			writer.Dispose();
			disposed = true;
		}

		/**** Private members ****/
		volatile bool abortConnect; StreamWriter writer;
		void connect() {
			Stream stream;
			try {
				stream = new TcpClient(Info.serv, Info.port).GetStream();
			}
			catch (SocketException) {
				Line(this, "Could not connect to \"" + Info.serv + "\".");
				return;
			}
			StreamReader reader = new StreamReader(stream);
			writer = new StreamWriter(stream);
			writer.AutoFlush = true;

			//Timer pingTimer = new Timer((TimerCallback) delegate {
			//   Message("PING :" + Info.serv);
			//}, null, 60000, 120000);

			Message("NICK " + Info.nick + "\n" + Info.user);

			string line; abortConnect = false;
			while (!abortConnect) {
				try { line = reader.ReadLine(); }
				// TODO: what is WSAConnection error?
				catch (IOException e) { Line(this, e.ToString()); break; }
				catch (OutOfMemoryException e) { Line(this, e.ToString()); break; }
				
				if (line == null || line.Length <= 1) continue;

				Line(this, line);
			}

			// pingTimer.Dispose();
			writer.Close(); reader.Close();
		} // connect()
	}
}